<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Lead Gen Pro - 3D Analysis Flow</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .header {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
        }

        h1 {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, #64b5f6 0%, #81c784 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            letter-spacing: -1px;
            text-shadow: 0 0 60px rgba(100, 181, 246, 0.5);
        }

        .subtitle {
            font-size: 1.2rem;
            color: #b0b0b0;
            font-weight: 300;
        }

        .info-panel {
            position: absolute;
            top: 50%;
            right: 40px;
            transform: translateY(-50%);
            width: 350px;
            background: rgba(26, 29, 46, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(100, 181, 246, 0.3);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        .info-panel h2 {
            font-size: 1.5rem;
            color: #f0f0f0;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-panel .icon {
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #64b5f6, #81c784);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .info-content {
            color: #d0d0d0;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .metric-card {
            background: rgba(30, 33, 48, 0.8);
            border: 1px solid rgba(100, 181, 246, 0.2);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, #64b5f6, #81c784);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .metric-label {
            font-size: 0.85rem;
            color: #a0a0a0;
            margin-top: 5px;
        }

        .controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: auto;
        }

        .control-btn {
            padding: 12px 24px;
            background: rgba(26, 29, 46, 0.9);
            border: 1px solid rgba(100, 181, 246, 0.3);
            border-radius: 30px;
            color: #e0e0e0;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(12px);
        }

        .control-btn:hover {
            background: rgba(100, 181, 246, 0.2);
            border-color: #64b5f6;
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(100, 181, 246, 0.3);
        }

        .control-btn.active {
            background: linear-gradient(135deg, #64b5f6, #81c784);
            color: #1a1d2e;
            font-weight: 600;
        }

        .legend {
            position: absolute;
            bottom: 40px;
            right: 40px;
            background: rgba(26, 29, 46, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(100, 181, 246, 0.3);
            border-radius: 16px;
            padding: 20px;
            pointer-events: auto;
        }

        .legend-title {
            font-size: 1.1rem;
            color: #f0f0f0;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-label {
            color: #d0d0d0;
            font-size: 0.9rem;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-content {
            text-align: center;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(100, 181, 246, 0.2);
            border-radius: 50%;
            border-top-color: #64b5f6;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: #b0b0b0;
            font-size: 1.1rem;
        }

        /* Accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Focus styles */
        .control-btn:focus {
            outline: 2px solid #64b5f6;
            outline-offset: 2px;
        }

        /* Animation for info panel */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-50%) translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateY(-50%) translateX(0);
            }
        }

        .info-panel {
            animation: slideIn 0.6s ease-out;
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">Initializing 3D Analysis Engine...</div>
        </div>
    </div>

    <div id="canvas-container"></div>
    
    <div class="ui-overlay">
        <div class="header">
            <h1>AI Lead Gen Pro</h1>
            <p class="subtitle">5-Pass Horsemen Analysis in 3D</p>
        </div>
        
        <div class="info-panel" id="infoPanel" style="display: none;">
            <h2>
                <div class="icon" id="nodeIcon">📊</div>
                <span id="nodeTitle">Select a Node</span>
            </h2>
            <div class="info-content" id="infoContent">
                Click on any node in the 3D visualization to see detailed information about that analysis stage.
            </div>
            <div class="metrics" id="metricsContainer"></div>
        </div>
        
        <div class="controls">
            <button class="control-btn active" onclick="setViewMode('rotate')">
                🔄 Rotate View
            </button>
            <button class="control-btn" onclick="setViewMode('flow')">
                ⚡ Show Data Flow
            </button>
            <button class="control-btn" onclick="setViewMode('explode')">
                💫 Exploded View
            </button>
            <button class="control-btn" onclick="resetView()">
                🎯 Reset View
            </button>
        </div>
        
        <div class="legend">
            <div class="legend-title">Analysis Stages</div>
            <div class="legend-item">
                <div class="legend-color" style="background: #64b5f6;"></div>
                <div class="legend-label">Data Collection</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #42a5f5;"></div>
                <div class="legend-label">Technical Analysis</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #66bb6a;"></div>
                <div class="legend-label">Business Intelligence</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #81c784;"></div>
                <div class="legend-label">Validation & Synthesis</div>
            </div>
        </div>
    </div>

    <script>
        // Scene setup
        let scene, camera, renderer, controls;
        let nodes = [];
        let connections = [];
        let particles = [];
        let currentMode = 'rotate';
        let selectedNode = null;
        let animationId = null;

        // Node data structure
        const nodeData = [
            {
                id: 'input',
                name: 'Input Sources',
                icon: '📥',
                position: { x: 0, y: 0, z: 0 },
                color: 0x64b5f6,
                info: 'Aggregates data from 12+ sources including job boards, company websites, and industry databases.',
                metrics: { sources: 12, dataPoints: '500K+' }
            },
            {
                id: 'brody',
                name: 'Brody Pass',
                icon: '🏇',
                position: { x: -30, y: 20, z: 20 },
                color: 0x42a5f5,
                info: 'Technical discovery phase identifying manual processes, repetitive tasks, and automation opportunities.',
                metrics: { patterns: 47, accuracy: '92%' }
            },
            {
                id: 'karen',
                name: 'Karen Pass',
                icon: '👩‍💼',
                position: { x: 30, y: 20, z: 20 },
                color: 0x66bb6a,
                info: 'Business intelligence analysis examining growth patterns, market position, and scalability factors.',
                metrics: { indicators: 23, confidence: '88%' }
            },
            {
                id: 'durin',
                name: 'Durin Pass',
                icon: '🛡️',
                position: { x: 0, y: 40, z: -20 },
                color: 0x81c784,
                info: 'Infrastructure validation assessing technical maturity, enterprise readiness, and integration capabilities.',
                metrics: { criteria: 15, score: '8.5/10' }
            },
            {
                id: 'kevin',
                name: 'Kevin Pass',
                icon: '🔍',
                position: { x: -20, y: 60, z: 0 },
                color: 0x66bb6a,
                info: 'Cross-validation phase verifying findings across multiple data sources and calculating confidence scores.',
                metrics: { validations: 34, reliability: '95%' }
            },
            {
                id: 'pinko',
                name: 'Pinko Pass',
                icon: '🎯',
                position: { x: 20, y: 60, z: 0 },
                color: 0x81c784,
                info: 'Strategic synthesis generating actionable recommendations, ROI projections, and implementation roadmaps.',
                metrics: { recommendations: 8, ROI: '245%' }
            },
            {
                id: 'output',
                name: 'Final Analysis',
                icon: '📊',
                position: { x: 0, y: 80, z: 0 },
                color: 0x64b5f6,
                info: 'Comprehensive automation opportunity report with scored recommendations and implementation strategies.',
                metrics: { score: '8.7/10', savings: '$680K' }
            }
        ];

        // Connection data
        const connectionData = [
            { from: 'input', to: 'brody' },
            { from: 'input', to: 'karen' },
            { from: 'brody', to: 'durin' },
            { from: 'karen', to: 'durin' },
            { from: 'durin', to: 'kevin' },
            { from: 'durin', to: 'pinko' },
            { from: 'kevin', to: 'output' },
            { from: 'pinko', to: 'output' }
        ];

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a0a, 100, 400);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 50, 150);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 300;
            controls.minDistance = 50;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0x64b5f6, 0.5, 100);
            pointLight1.position.set(-50, 50, 0);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x81c784, 0.5, 100);
            pointLight2.position.set(50, 50, 0);
            scene.add(pointLight2);

            // Create nodes
            createNodes();

            // Create connections
            createConnections();

            // Create particle system
            createParticleSystem();

            // Add grid helper
            const gridHelper = new THREE.GridHelper(200, 20, 0x2a2a2a, 0x1a1a1a);
            gridHelper.position.y = -20;
            scene.add(gridHelper);

            // Raycaster for mouse interaction
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer.domElement.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);

            function onMouseClick(event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(nodes.map(n => n.mesh));

                if (intersects.length > 0) {
                    const clickedNode = nodes.find(n => n.mesh === intersects[0].object);
                    selectNode(clickedNode);
                }
            }

            // Hide loading screen
            setTimeout(() => {
                const loadingScreen = document.getElementById('loadingScreen');
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 1500);

            animate();
        }

        function createNodes() {
            const sphereGeometry = new THREE.SphereGeometry(8, 32, 32);
            const ringGeometry = new THREE.RingGeometry(10, 12, 32);

            nodeData.forEach(data => {
                // Create node sphere
                const material = new THREE.MeshPhysicalMaterial({
                    color: data.color,
                    emissive: data.color,
                    emissiveIntensity: 0.2,
                    metalness: 0.8,
                    roughness: 0.2,
                    clearcoat: 1,
                    clearcoatRoughness: 0
                });

                const mesh = new THREE.Mesh(sphereGeometry, material);
                mesh.position.set(data.position.x, data.position.y, data.position.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);

                // Create glowing ring
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: data.color,
                    opacity: 0.3,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(mesh.position);
                scene.add(ring);

                // Create label sprite
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                context.fillRect(0, 0, 256, 64);
                
                context.font = '24px Arial';
                context.fillStyle = '#ffffff';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(data.name, 128, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(20, 5, 1);
                sprite.position.copy(mesh.position);
                sprite.position.y += 15;
                scene.add(sprite);

                nodes.push({
                    id: data.id,
                    data: data,
                    mesh: mesh,
                    ring: ring,
                    sprite: sprite
                });
            });
        }

        function createConnections() {
            connectionData.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);

                if (fromNode && toNode) {
                    const points = [];
                    points.push(fromNode.mesh.position);
                    
                    // Create curved path
                    const midPoint = new THREE.Vector3(
                        (fromNode.mesh.position.x + toNode.mesh.position.x) / 2,
                        (fromNode.mesh.position.y + toNode.mesh.position.y) / 2,
                        (fromNode.mesh.position.z + toNode.mesh.position.z) / 2
                    );
                    midPoint.x += (Math.random() - 0.5) * 20;
                    midPoint.z += (Math.random() - 0.5) * 20;
                    
                    const curve = new THREE.QuadraticBezierCurve3(
                        fromNode.mesh.position,
                        midPoint,
                        toNode.mesh.position
                    );

                    const geometry = new THREE.TubeGeometry(curve, 50, 0.5, 8, false);
                    const material = new THREE.MeshPhysicalMaterial({
                        color: 0x64b5f6,
                        emissive: 0x64b5f6,
                        emissiveIntensity: 0.5,
                        metalness: 0.9,
                        roughness: 0.1,
                        opacity: 0.8,
                        transparent: true
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    scene.add(mesh);

                    connections.push({
                        from: conn.from,
                        to: conn.to,
                        mesh: mesh,
                        curve: curve
                    });
                }
            });
        }

        function createParticleSystem() {
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = 1000;
            const posArray = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 300;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 1,
                color: 0x64b5f6,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const particleMesh = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleMesh);
            particles.push(particleMesh);
        }

        function selectNode(node) {
            if (selectedNode) {
                // Reset previous selection
                gsap.to(selectedNode.mesh.scale, {
                    x: 1, y: 1, z: 1,
                    duration: 0.3,
                    ease: 'power2.out'
                });
            }

            selectedNode = node;
            
            // Animate selection
            gsap.to(node.mesh.scale, {
                x: 1.3, y: 1.3, z: 1.3,
                duration: 0.3,
                ease: 'power2.out'
            });

            // Update info panel
            document.getElementById('infoPanel').style.display = 'block';
            document.getElementById('nodeIcon').textContent = node.data.icon;
            document.getElementById('nodeTitle').textContent = node.data.name;
            document.getElementById('infoContent').textContent = node.data.info;

            // Update metrics
            const metricsContainer = document.getElementById('metricsContainer');
            metricsContainer.innerHTML = '';
            
            Object.entries(node.data.metrics).forEach(([key, value]) => {
                const metricCard = document.createElement('div');
                metricCard.className = 'metric-card';
                metricCard.innerHTML = `
                    <div class="metric-value">${value}</div>
                    <div class="metric-label">${key.charAt(0).toUpperCase() + key.slice(1)}</div>
                `;
                metricsContainer.appendChild(metricCard);
            });
        }

        function setViewMode(mode) {
            currentMode = mode;
            
            // Update button states
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            switch (mode) {
                case 'rotate':
                    controls.autoRotate = true;
                    resetNodePositions();
                    break;
                    
                case 'flow':
                    controls.autoRotate = false;
                    showDataFlow();
                    break;
                    
                case 'explode':
                    controls.autoRotate = false;
                    explodeView();
                    break;
            }
        }

        function showDataFlow() {
            // Animate particles along connections
            connections.forEach((conn, index) => {
                const delay = index * 0.2;
                
                gsap.to(conn.mesh.material, {
                    emissiveIntensity: 1,
                    duration: 0.5,
                    delay: delay,
                    yoyo: true,
                    repeat: -1,
                    ease: 'power2.inOut'
                });
            });
        }

        function explodeView() {
            nodes.forEach(node => {
                const targetPos = node.mesh.position.clone();
                targetPos.multiplyScalar(1.5);
                
                gsap.to(node.mesh.position, {
                    x: targetPos.x,
                    y: targetPos.y,
                    z: targetPos.z,
                    duration: 1,
                    ease: 'power2.inOut'
                });

                gsap.to(node.sprite.position, {
                    x: targetPos.x,
                    y: targetPos.y + 15,
                    z: targetPos.z,
                    duration: 1,
                    ease: 'power2.inOut'
                });

                gsap.to(node.ring.position, {
                    x: targetPos.x,
                    y: targetPos.y,
                    z: targetPos.z,
                    duration: 1,
                    ease: 'power2.inOut'
                });
            });
        }

        function resetNodePositions() {
            nodes.forEach(node => {
                const originalPos = node.data.position;
                
                gsap.to(node.mesh.position, {
                    x: originalPos.x,
                    y: originalPos.y,
                    z: originalPos.z,
                    duration: 1,
                    ease: 'power2.inOut'
                });

                gsap.to(node.sprite.position, {
                    x: originalPos.x,
                    y: originalPos.y + 15,
                    z: originalPos.z,
                    duration: 1,
                    ease: 'power2.inOut'
                });

                gsap.to(node.ring.position, {
                    x: originalPos.x,
                    y: originalPos.y,
                    z: originalPos.z,
                    duration: 1,
                    ease: 'power2.inOut'
                });
            });
        }

        function resetView() {
            controls.reset();
            resetNodePositions();
            setViewMode('rotate');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            animationId = requestAnimationFrame(animate);

            // Update controls
            controls.update();

            // Animate rings
            nodes.forEach(node => {
                node.ring.rotation.z += 0.01;
                
                // Pulse effect
                const scale = 1 + Math.sin(Date.now() * 0.001 + nodes.indexOf(node)) * 0.1;
                node.ring.scale.set(scale, scale, 1);
            });

            // Animate particles
            particles.forEach(particleMesh => {
                particleMesh.rotation.y += 0.0005;
                
                const positions = particleMesh.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.1;
                }
                particleMesh.geometry.attributes.position.needsUpdate = true;
            });

            renderer.render(scene, camera);
        }

        // Initialize the scene
        init();
    </script>
</body>
</html>